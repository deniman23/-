
## 1. Введение в Spring

**Spring Framework** – это мощный фреймворк для разработки приложений на **Java**, предоставляющий обширную инфраструктуру и конфигурационную модель для современных корпоративных приложений. Вот некоторые ключевые аспекты Spring**:**

1.     **Spring Core**: Этот модуль содержит контейнер компонентов Spring Beans, который управляет жизненным циклом объектов и их зависимостями.

2.     **Spring Context**: Предоставляет функциональность для создания и управления контекстами приложения.

3.     **Spring DAO**: Обеспечивает инфраструктуру для обработки транзакций, работы с интерфейсами JDBC и объектами DAO (Data Access Object).

4.     **Spring ORM**: Поддерживает интеграцию с [[Конспект по Hibernate]] для работы с базами данных.

5.     **Spring Web**: Предоставляет инструменты для создания веб-приложений.

6.     **Spring Аспектно ОП (AOP)**: Позволяет создавать сквозную логику, например, для регистрации и логирования.

Позже Spring был дополнен множеством функций:

·         **Поддержка реактивного программирования**: Spring поддерживает реактивные паттерны для асинхронной обработки данных.

·         **Внедрение аннотаций**: Аннотации, такие как @Autowired, @Component, @Service и @Controller, упростили процесс конфигурации и управления компонентами.

·         **Улучшения в тестировании**: в Spring 5.0.x были значительные улучшения в модуле тестирования, включая поддержку JUnit 5 и новые аннотации для более гибкого управления тестами.

Основой Spring Framework является принцип **внедрения зависимостей (IoC)**. Вместо того чтобы создавать и искать зависимые объекты, Spring предоставляет их из внешних источников, таких как контейнер IoC.

Другие важные аспекты Spring:

·         **Spring Expression Language (SpEL)**: Используется для запросов и манипуляций с объектами во время выполнения программы. Например, можно обращаться к системным свойствам через аннотацию @Value ("#{systemProperties['user.region']}").

·         **Валидация данных**: Spring предоставляет интерфейс Validator для проверки корректности данных. Также есть Java Bean Validation, позволяющий аннотировать объекты с ограничениями, такими как @NotNull, @Max, @Min.

·         **Java OXM**: Для общения с другими приложениями через XML используется Java OXM

## 2. Инверсия управления и внедрение зависимостей

**Инверсия управления и Внедрение зависимостей** направлено на поставку для компонента зависимостей и управления ими. Компонент, которому требуется зависимости называют **зависимым объектом**. Следовательно, **инверсию управления** можно разделить на два подтипа это: **внедрение зависимостей** и **поиск зависимостей.**

Если используется **поиск зависимостей**, то компонент должен **получать ссылку на зависимость**, а при **внедрении зависимости,** зависимости внедряются в компонент **через контейнер инверсии управления**.

У **поиска зависимостей** имеются две разновидности: **извлечение зависимостей** и **контекстный поиск зависимостей** (CDL).

И у **внедрения зависимостей** имеются две разновидности: **через конструктор** и **через метод установки.**

В общем и целом, инверсия управления и внедрение зависимостями делятся на поиск зависимостей или их внедрение. Поиск может брать зависимости из реестра или из контейнера, а внедрение происходит с помощью конструктора или метода назначения.

**В** **Spring** **используется внедрение зависимостей через** **Bean** **компоненты**

*        Ядром контейнера в Spring является **Bean** **factory**, он отвечает за управление компонентами Spring Beans, в том числе их зависимостями и жизненными циклами. Под Bean компонентом понимается любой компонент управляемый контейнером.

*       **BeanFactory** представляет собой контейнер, который инстанцирует, конфигурирует и управляет несколькими бинами. Эти бины обычно взаимодействуют друг с другом и могут иметь зависимости между собой .

*      Можно использовать BeanFactory для инициализации бинов, но сейчас используют ApplicationContext, который является расширением BeanFactory. 

*        Аннотация **@Autowired** указывается над методами или конструкторами чтобы показать какие аргументы должны быть вызваны у класса. Так же ниже используется @Value для передачи значения в message. Если конструкторов два, то аннотацию надо указывать над тем который должен сработать первый.   

Так же **@Autowired** может быть указан над полем и предоставь доступ к классу типа которого является данное поле. @**Bean** используется для методов чтоб указать что возвращаемое значение этого метода должен быть зарегистрирован как бин. А эти методы объявляют в классе обозначенным аннотацией @Configuration чтобы показать, что это конфигурационный класс. Но тогда в ApplicationContext создает объект через new AnnotationConfigApplicationContext и созданные бины надо будет вызвать через getBean(), либо использовать @ComponentScanning на конфигурационном файле.

**Области видимости** **Bean** **компонентов**

В Spring Framework существуют различные области видимости (scopes) для компонентов Bean, которые определяют жизненный цикл и видимость бинов в приложении. Вот основные области видимости:

• **singleton (Одиночный экземпляр):** Это область видимости по умолчанию. Контейнер создаёт единственный экземпляр бина для каждого контейнера Spring IoC. Все последующие запросы на этот бин будут возвращать тот же самый экземпляр.

• **prototype (Прототип):** Каждый запрос на бин приведёт к созданию нового экземпляра. Это полезно, когда каждое использование бина должно быть независимым от других.

• **request (Запрос):** Создаётся новый бин для каждого HTTP-запроса. Эта область видимости применима только в контексте веб-приложений.

• **session (Сеанс связи):** Создаётся новый бин для каждой HTTP-сессии. Также используется только в веб-приложениях.

• **global-session (Глобальный сеанс):** Бин создаётся для глобальной HTTP-сессии.

**Получение экземпляров в** **Spring**

В Spring Framework, получение экземпляров относится к процессу, когда IoC контейнер создает и предоставляет бины, которые являются объектами, управляемыми Spring. Этот процесс включает в себя следующие шаги:

1. **Определение бина**: Конфигурация бина описывается в XML, Java-конфигурации или с помощью аннотаций.

2. **Создание бина**: Когда приложение запускается, Spring IoC контейнер создает экземпляры бинов согласно их определениям.

3. **Внедрение зависимостей**: Контейнер внедряет все необходимые зависимости в бин через конструктор, сеттеры или поля.

4. **Получение бина**: Приложение может запрашивать бины из контейнера напрямую через метод getBean() или автоматически через аннотации, такие как @Autowired, @Required, @Resource.

**Управление жизненным циклом компонентов** **Spring** **Bean**

В каркасе Spring предоставляются три механизма, которые можно применять в компоненте Spring Bean для **выполнения дополнительной обработки**. Эти механизмы основаны на **интерфейсах**, **методах** **и аннотациях** соответственно.

Управление жизненным циклом компонентов Spring Bean включает в себя несколько ключевых этапов, которые позволяют контролировать создание, использование и уничтожение бинов. Вот основные моменты **обратного** **вызова при инициализации**:

1. **Инициализация**: После того как бин создан, используя конструктор или фабричный метод, Spring Framework предоставляет возможность настроить бин с помощью методов инициализации. Это может быть реализовано через интерфейс **InitializingBean** или аннотацию **@PostConstruct** или через xml. То есть после того как Spring проверил все зависимости бина запускается метод из **InitializingBean**, либо использовать **@****PostConstruct** который указывается над методом, который должен работать с бином.

2. **Уничтожение**: Когда контейнер Spring закрывается, он уничтожает бины, которые требуют освобождения ресурсов. Это можно сделать через интерфейс **DisposableBean** с методом destroy(), аннотацию **@PreDestroy**, или указать метод уничтожения в конфигурации бина с помощью атрибута destroy-method. Методы уничтожения обычно используются для освобождения ресурсов, таких как закрытие соединений с базой данных, остановка потоков или удаление временных файлов.

Аннотация **@Bean** может использоваться в классах с аннотацией **@Configuration** для создания бинов. Кроме того, с помощью аннотации можно указывать методы инициализации и уничтожения бина, что дает дополнительный контроль над жизненным циклом бина. Например, можно определить методы init() и destroy() и указать их в аннотации (@Bean(initMethod = "init", destroyMethod = "destroy"))

**Применение фабрик компонентов Spring Beans**

Фабрики Spring позволяют создавать объекты для нашего приложения. Не используя new, а через специальные фабричные методы и аннотации @Bean.

**Редакторы свойств в** **Spring**

Они позволяют управлять преобразованием между строковыми значениями и пользовательскими типами объектов. Это основано на Java Beans PropertyEditor, который является частью стандартного набора JavaBeans
  
**Преимущество использования** **ApplicationContext**

**Наибольшая выгода** от применения интерфейса **ApplicationContext** состоит в том, что он позволяет конфигурировать каркас Spring и управлять им и его ресурсами полностью декларативным способом. Вот несколько причин, по которым ApplicationContext считается более подходящим выбором:

·        **Интернационализация** с помощью интерфейса **_MessageSource._**  Через интерфейс MessageSource приложение может получать доступ к строковым ресурсам типа String, называемым сообщениями и хранящимся на разных языках. Для каждого языка, который должен поддерживаться в приложении, предоставляется список сообщений с ключами соответствия сообщений на других языках. Т е интерфейс адаптируется под другой язык.

·        **События в приложениях.** Это механизм для обмена информацией между различными компонентами приложения. Они позволяют компонентам реагировать на различные действия или изменения состояния в приложении без необходимости знать о существовании друг друга, что уменьшает связность и увеличивает модульность**.**

·        **Доступ к ресурсам.** Позволяет получать доступ к ресурсам в файловой системе не зависимо от их протокола, с помощью интерфейса Resource.

**Конфигурирование с помощью классов в** **Java**

В основе программы лежит конфигурационный класс, который снабжен аннотацией @Configuration Этот класс будет содержать методы с аннотацией @Bean. Так же существуют профили, которые помогают уточнить к какому классу надо относить компонент с помощью @Profile. Так же чтобы не использовать @Configuration, @ComponentScan, @EnableAfterConfiguration можно использовать @SpringBootApplication

**Для объявления веб-компонентов** Spring Beans применяется аннотация **@Controller** как особая разновидность аннотации @Component. Классы типа контроллеров содержат методы, снабженные аннотацией **@RequestMapping**, благодаря которой они отображаются на определенный URL запроса.

**Аспектное ориентированное программирование**

**Аспектное-ориентированное программирование** (АОП) в Spring позволяет разделять сквозную функциональность (например, логирования, транзакции) от бизнес-логики. Т е позволяет создавать сквозную логику не задевая основную.

Существуют два типа АОП **статическое** и **динамическое**, отличаются они где происходит процесс связывания и как он осуществляется. 

Основные концепции:

·        **Аспект.** Сквозная логика, которая пересекает несколько классов.

·        **Совет.** Предоставляет дополнение к логике, которое аспект вносит в программу (доп. поведение). Существует три типа совета: before, after и around.

·        **Срез.** Делается с помощью аннотации @PointCut. В описании которого указывается где должен быть срез, а затем аннотациями @Before, @After и т д указываю куда надо вставить аспект.

Для использования АОП в программе используются такие аннотации как: @Aspect (Объявляет класс как аспект), @Before (с указанием где должна быть внедрена логика аспекта) и **@EnableAspectJAutoProxy** (указывается в классе конфигурации для использования АОП).

Существуют объекты **заместители,** которые перехватывают вызовы методов **(целевых объектов**) из **клиентов** (классы в которых вызываются целевые объекты) и передаёт эту информацию если надо вызвать аспект.