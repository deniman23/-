Шаг 1. Короткий запрос или длинный?
Первый шаг – определить, является рассматриваемый запрос коротким или длинным. Как обсуждалось в главах 5 и 6, изучение самого запроса не обязательно поможет вам найти ответ. Вспомните, что оптимизация запросов начинается со сбора требований и важно работать вместе с владельцами бизнеса, с бизнес-аналитиками или со всеми вместе.
Проверьте, важны ли компании самые свежие данные или нужно исследовать исторические тенденции и т. д. Представители бизнеса могут сказать, что им нужны все отмененные рейсы, но стоит спросить, хотят ли они увидеть все отмененные рейсы с начала времен или все-таки за последние сутки. Если вы определили, что рассматриваемый запрос является коротким, переходите к шагу 2; в противном случае переходите к шагу 3.

Шаг 2. Короткий запрос
Итак, вы имеете дело с коротким запросом. Какие шаги необходимо предпринять, чтобы не только написать запрос наилучшим образом, но и чтобы его производительность была стабильной даже при росте объема данных?

Шаг 2.1. Самые ограничительные критерии Найдите самые ограничительные критерии для вашего запроса. Помните, что зачастую для этого недостаточно просто посмотреть на запрос. Проверьте таблицы, чтобы найти количество различных значений атрибутов.
Помните о распределении значений, выясните, какие значения встречаются Пошаговое руководство реже всего. Когда наиболее ограничительные критерии будут определены,
переходите к следующему шагу.

Шаг 2.2. Проверьте индексы
Проверьте, созданы ли индексы, поддерживающие поиск по наиболее ограничительным условиям. А именно:
 проверьте, проиндексированы ли все атрибуты поиска для наиболее
ограничительного условия. Если индекс (или индексы) отсутствует,
запросите создание или создайте сами;
 если задействовано несколько полей, проверьте, будет ли составной
индекс работать лучше и оправдывает ли прирост производительности
создание дополнительного индекса;
 проверьте, можно ли использовать сканирование только индекса с ис-
пользованием составного или покрывающего индекса.
Шаг 2.3. Добавьте избыточный критерий отбора,
если это применимо
Если наиболее ограничительное условие основано на комбинации атрибутов
из разных таблиц и поэтому не может быть проиндексировано, подумайте
о добавлении избыточного критерия отбора.
Шаг 2.4. Построение запроса
Начните писать запрос, применяя самые ограничительные критерии; для этого может потребоваться начать запрос с одной таблицы или с соединения, которое включает в себя наиболее ограничительный критерий. Не пропускайте этот шаг. Часто, когда разработчики баз данных знают связи между объектами, они выписывают все соединения перед применением фильтрации. Хотя мы знаем, что такой подход нередко рекомендуется, мы считаем, что в случае сложных запросов со многими соединениями он может
усложнить разработку. Мы предлагаем начать с запроса, который точно выполняется эффективно, и затем добавлять по одной таблице за раз. Проверяйте производительность запроса и план выполнения каждый раз, когда добавляете новое соединение. Помните, что оптимизаторы склонны ошибаться при оценке размера промежуточных результатов по мере приближения к корню дерева выполнения. Если количество соединений в запросе приближается к десяти, стоит рассмотреть возможность использования общих табличных выражений (если вы используете версию 12 или выше) или подумать о создании динамического SQL.

Шаг 3. Длинный запрос
Вы имеете дело с длинным запросом. Сначала определите, можно ли ис-
пользовать инкрементальное обновление. Здесь вам снова нужно поработать
вместе с владельцем бизнеса и бизнес-аналитиками, чтобы лучше понять,
Полный и окончательный алгоритм оптимизации
какова цель запроса. Часто требования формулируются без учета динамики
данных. Когда результаты запроса хранятся в таблице и должны периодиче-
ски обновляться, данные можно каждый раз получать заново (полное обнов-
ление, извлекающее все данные от начала времен до последнего момента),
а можно получать постепенно, добавляя только то, что изменилось с момента
последнего обращения. Последний способ и есть то, что мы подразумеваем
под инкрементальным обновлением. В подавляющем большинстве случаев
данные можно получать постепенно. Например, вместо создания материа-
лизованного представления passenger_passport, которое было показано в гла-
ве 7, создайте его как таблицу и добавляйте к ней строки (или обновляйте их)
при вводе новых паспортных данных.
Если есть возможность использовать инкрементальное обновление, пере-
ходите к шагу 4; в противном случае переходите к шагу 5.
Шаг 4. Инкрементальные обновления
Рассматривайте запрос недавно добавленных или обновленных записей как
короткий, причем наиболее ограничительным критерием в этом случае яв-
ляется время обновления. Переходите к шагу 2 и выполняйте шаги по опти-
мизации коротких запросов.
Шаг 5. Неинкрементальный длинный запрос
Если инкрементальное обновление невозможно, выполните следующие шаги
по оптимизации длинных запросов:
 найдите наиболее ограничительное соединение, полусоединение или
антисоединение, если это применимо (подробности см. в главе 6),
и убедитесь, что оно выполняется первым;
 продолжайте соединять таблицы одну за другой и каждый раз прове-
ряйте время выполнения и план выполнения;
 убедитесь, что большие таблицы не сканируются многократно. Плани-
руйте запрос так, чтобы он читал большие таблицы только один раз,
как описано в главе 6;
 обратите внимание на группировку. В большинстве случаев стоит отло-
жить группировку до последнего шага, то есть нужно убедиться, что GROUP
BY является последней командой в плане выполнения. Помните о случа-
ях, описанных в главе 6, когда группировку следует выполнять раньше,
чтобы минимизировать размер промежуточных наборов данных.
Но подождите, это еще не все!
На протяжении всей книги мы настаивали на том, что оптимизация базы
данных не ограничивается оптимизацией отдельных запросов; отдельные
запросы не берутся из ниоткуда. Алгоритм оптимизации, описанный в пре-
Выводы  273
дыдущих разделах, является руководством только для процесса оптимизации
отдельного запроса или, скорее, правильного написания запроса с самого
начала. Однако мы рассмотрели и несколько других методов.
Вот что еще следует учитывать:
 параметры – скорее всего, запрос, который вы оптимизируете, параметризован,
то есть если вы имеете дело с идентификатором рейса, то это
не фиксированное значение flight_id = 1234, а произвольный номер.
Как мы обсуждали в главе 5, от конкретных значений может зависеть,
какое из условий окажется самым ограничительным (например, статус
отмены рейса будет более ограничительным, чем большинство других
критериев);
 динамический SQL – если от значений зависит, какое из условий явля-
ется наиболее ограничительным, или сами условия могут меняться –
правильным подходом будет использование динамического SQL;
 функции – как обсуждалось в главе 11, сами по себе функции не улуч-
шают производительность и даже могут значительно увеличить время
выполнения. Однако если необходим динамический SQL, без функций
обойтись сложно;
 изменения в структуре базы данных – работая с запросами, вам может
потребоваться выполнить команды DDL, от создания новых индексов
до изменения схемы таблицы. Вам нужно будет поработать с администраторами
баз данных и системными архитекторами, чтобы опре-
делить, какие изменения можно реализовать;
 взаимодействие с приложением – ваш запрос выполняется приложени-
ем; производительность запроса может быть довольно хорошей, а об-
щая производительность приложения при этом – нет. Если вы и ваша
команда решите использовать NORM или другой подобный подход,
нужно будет поработать с разработчиками приложений, чтобы опре-
делить, что принадлежит бизнес-логике, а что – логике базы данных,
как описано в главах 11 и 13.