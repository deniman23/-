Главным за оптимизацию отвечает **оптимизатор запросов**. Задача оптимизатора – построить наилучший возможный физический план, реализующий определенный логический план

[[Пошаговое руководство создания индекса]]

![[Pasted image 20240712130840.png]]
## 1. Построение запроса   

Построение запроса лучше делать от лица программы, как будто строишь запрос сам себе. Лучше сразу оптимизировать его, а не пытаться потом.

Базы данных разделяются на два класса **OLTP** (оперативная обработка транзакций) и **OLAP** (интерактивная аналитическая обработка). OLTP-системы поддерживают приложения, а OLAP-системы – бизнес-аналитику и отчетность.

**OLTP** - это обработка сразу нескольких транзакций в реальном времени. Покупки, ввод.
**OLAP** - транзакции для обработки данных и бизнес-анализа
## 2. Структура и виды запросов

Виды запросов: 
* **Фильтрация**. Фильтрация согласно условию 
* **Проекция.** Возвращает только уникальные столбцы
* **Произведение**. Возвращает все возможные строки для двух таблиц  
## 3. Алгоритмы запросов

Получить доступ к данным в таблице можно по индексу. Индекс избыточная структура и не несет какой либо информации которой нет в основной таблице. Так же индексы знают дополнительные пути для получения информации БЕЗ ЧТЕНИЯ таблицы. 

Есть два вида чтения данных, по индексу и по битовой карте. По индексу оно сканирует все индексы и выбирает нужные подходящие условию, а битовая карта создает схему по которой потом проходит фильтрация данных, она позволяет избежать повторов т.к. всё лежит в куче, но она более затратная.

Индексы за счет того что избыточны теряют в скорости исполнения алгоритма, например если данные в таблице меняются на которое указывает индекс, то надо провести ещё операцию по обновлению данных в индексе. Сами они состоят из ключа и ссылки на поле которое указывают

> В базах данных таблицы часто хранятся в структуре, называемой кучей, где данные располагаются в неупорядоченном виде. Индексы используются для ускорения поиска данных в таблицах. Они могут быть построены с использованием структуры данных, известной как B-дерево. В каждом узле B-дерева хранится ключ и ссылка (или указатель) на соответствующее значение или запись в таблице.
> 
### B-Дерево

Структура для хранения данных, позволяющая быстро получать вставлять и изменять данные. Скорость действий будет не быстрее чем logn где n это количество элементов. Т.к. делает обход с помощью бинарного поиска.  Лучше всего подходит для хранениях на дисках т.к. меньше действий требует. При вставке если уже нет места , 2 элемент или средний отправляется наверх узла, а для двух других создается два новых узла и они раскидываются в лево право соответственно.

### Битовая карта 

Создает таблицу которая проверяет соответствует ли указанному индексу условие, 1 - да и 0 - нет, и объединяя их с помощью логических операторов И, ИЛИ.  

### Вложенные циклы

Стандартный алгоритм цикл перебора всех данных. Скорость выполнения прямо пропорционально количеству данных. Цикл можно улучшать и изменять под нужные запросы.

### Алгоритмы соединения хэшированием 

Суть соединения в том что берется две таблицы, та в которой меньше количество значений заносится в хэш для быстрого поиска, столбцы являются ключами а строки значениями. Ключи находятся в другой таблице и соединяются. Так работает JOIN. Чтобы найти подходящие строки для этого используются вложенные циклы.

### Сортировка слиянием

Таблицы сортируются по возрастанию и потом постепенно проходятся для поиска соответствующих ключей и соединяет их.

## 4. Короткие запросы и индексы

**Индекс** - это структура которая является избыточной(т е её можно удалить и восстановить данные откуда-то), они невидимы для приложения, и они улучшают поиск данных в таблице.  

Короткими запросами считаются запросы которые используют малое количество строк (10% от всей таблицы)

Обязательной частью ускорения запросов является **селективность индексов**, т е чем больше значений соответствующих для индексов тем больше значение селективности. Чем ниже селективность тем быстрее выполняется поиск. Самые эффективные индексы уникальные 

**Селективность индекса - это насколько хорошо индекс справляется с разбором данных**

**Селективность данных - это насколько условия фильтра совпадает со всеми данными в таблице, если соответствует многим фильтр то это низкая селективность и это плохо т.к. и так придется много данных обходить**

При создании внешнего ключа не гарантируется создание индекса. 

**GIN индекс** лучше создавать при работе с поиском по тексту, **GIST индекс** при работе с координатами. 

### Виды индексов:
 
1. **Уникальный индекс**: Гарантирует, что все значения в индексируемом столбце уникальны. Это полезно для обеспечения целостности данных, например, для первичных ключей
2. **Неуникальный индекс**: Индекс, в котором значения могут повторяться. Он может ускорять доступ к данным, даже если значения не уникальны
3. **Простой индекс**: Индекс, состоящий из одного поля. Это базовый тип индекса, который ускоряет поиск по одному столбцу
4. **Составной индекс**: Индекс, построенный по нескольким столбцам таблицы. Он полезен для запросов, которые фильтруют или сортируют данные по нескольким столбцам
5. **Древовидный индекс**: Наиболее распространенный тип индекса, который представлен в виде корневой вершины и узлов. Он обеспечивает эффективный поиск как точных значений, так и диапазонов значений
6. **Хэш-индекс**: Использует хеш-функцию для прямого доступа к данным. Хэш-индексы эффективны для операций равенства, но не подходят для поиска диапазонов

### Индексы не используются: 

 1. **Маленькие таблицы**: Если таблица содержит небольшое количество строк, полный перебор может быть быстрее, чем использование индекса из-за накладных расходов на его обслуживание.
2. **Частые операции записи**: В таблицах с высокой частотой вставки, обновления или удаления строк, индексы могут замедлить эти операции, так как каждый раз придется обновлять индекс.
3. **Столбцы с низкой селективностью**: Если столбец имеет много повторяющихся значений (низкая селективность), индекс может не принести значительного улучшения производительности.
4. **Широкие индексы**: Индексы, включающие множество столбцов или столбцы с большими данными, могут быть неэффективными и занимать много места.
5. **Отсутствие поддержки запросов**: Если типы запросов, выполняемых в системе, не используют индексы, то их наличие будет лишь нагрузкой.
6. **Распределенные системы**: В распределенных базах данных индексы могут усложнить согласованность данных и увеличить время отклика.
7. **Полные сканирования**: Если запросы обычно требуют полного сканирования таблицы, индексы могут оказаться бесполезными.


## 5. Длинные запросы 

**Длинный запрос** - это запрос который работает с более чем 10% строк от всей таблицы. 

> Хорошей практикой является использование **JOIN** вместо полусоединений, программе легче читается и СУБД легче понять этот запрос. 

**Полусоединение** - это процесс когда две таблицы соединяются по общим найденным столбцам не возвращая вторую таблицу 

> Как и короткие запросы, длинные запросы оптимизируются за счет уменьшения размера промежуточных результатов и выполнения необходимой работы с как можно меньшим количеством строк. В случае с короткими запросами это достигается путем применения индексов по наиболее ограничительным критериям. В случае с длинными запросами это достигается за счет выбора правильного порядка соединений, использования полу- и анти-
> соединений, применения фильтрации перед группировкой и группировки перед соединением, а также использования операций над множествами


Существует практика **временных таблиц** *использование которых не рекомендуется* , т к например индексы в исходной таблице не будут во временной, надо их будет там создавать. Важно что использование их допускается, но не чрезмерное. 
Вместо них можно использовать **CTE** - это те же временные таблицы, но они существуют только на время запроса.

До этого мы разделяли запросы на более мелкие, теперь можно попробовать разделять на мелкие секции данные это называется - **Секционирование**.


## 6. Оптимизация модификации данных

При низкоуровневой работе главные две операции - это чтение и запись. Главное правило для чтения что его нельзя завершить до записи на диск, а операция изменения должно быть завершено до записи на диск.

Одной из возможных проблем при работе с изменениями это взаимоблокировка. Если поступает две задачи, то та которая пришла позже блокируется до окончания первой. Поэтому лучше использовать разные транзакции для разных запросов. 

Существует **суррогатный ключ** который позволяет дополнительно сделать уникальными данные. Например если в таблица два одинаковых предмета с одинаковыми полностью значениями.


